-figure out the memory layout, no need for rows cols capacity, maybe consider storing position of the cell as well, position will add 2*8 bytes, with 8 for length, that will be 24 bytes of metadata which i think is better, because the cells will be contiguous for cache locality, so the operations can be very fast, which is the point of this, or maybe figure out something else.
-if more memory needed to store the data, realloc the buffer with double the size, if more memory needed, say more than 128 chars, malloc that specific cell, so the rest will not get bigger for no benefit
note: maybe seperate teh cells as cells holding doubles, chars and cells to be parsed, so everything is contiguous, cells with doubles are contiguous and stored by row, cells with chars contiguous in the case of sorting by name for example, cells to be parsed also contiguous so parsing is efficient, maybe? so many hypothesis but no testing.
note: how to allow user to modify cells that contains doubles? at any time they can modify the value, maybe copy the table, one copy only cells holding doubles, and the other for chars.
todo: make node struct use relative pointers instead of absolute for right,left
todo: major refactoring, names, simplifying Split(), avx version for Split() Trim() ...
todo: fix get set erase cells, fix FillCells()
note: the one thing i haven't anticipated is fragmentation, if the user clicked on one cell, it will be added in the CellPos array, even without data, except if that cell got used again, cells wil lstill be contiguous especially compared to the previous approach, which was better in terms of getting and setting the cells because i was indexing the directly by row col position, now we need to traverse all of them to find the position we need, but the previous one had a lot of empty space which of course meant that the cells are not contiguous, which maybe doesn't perform as good as if the cells were?
todo: profile everything, i have no idea which memory layout is better
